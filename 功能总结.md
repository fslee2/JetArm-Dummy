# 已完成功能总结

> 本文档汇总目前在 *Plan* 调试阶段已 **实现/补充** 的所有功能及要点，并摘录了
> 若干关键实现代码，便于快速了解核心逻辑。

---

## 1. `teleop_debug_node.py` – 非侵入式调试中继脚本

| 功能类别 | 具体实现 |
| --- | --- |
| **外部调用** | - 自动引入主臂 SDK（`ros_robot_controller_sdk`）与 `teleop_mapping.py` 的映射逻辑。<br>- 尝试连接真实 `DummyRobot`；若库不存在则退化到 `dummy_robot_simulator.py`，完全无需修改原始文件。 |
| **主循环数据流** | 1. 读取主臂脉冲 → 角度 (`read_positions` → `pulse_to_angle`) 。<br>2. 调用 `calculate_follower_angles` 获得从臂目标角度。<br>3. 支持全局 `scale` 与逐关节 `offsets` 二级手动调参。<br>4. 角度 → 计数 (`angle_to_counts`) 并（可选）发送至从臂控制接口。 |
| **终端输出** | - 采用双行刷新技巧，将 *Leader* 与 *Follower* 角度实时对比呈现，信息紧凑且无闪烁。 |
| **安全 / 校准** | - 启动时计算 *Follower* 当前 Home 姿态与映射目标角度的最大绝对差。<br>- 当差值超过 `--safety_deg`（默认 15°）时，锁止下发，仅监视数据，避免误动作。<br>- 通过阈值后自动解锁并开始同步。 |
| **运行模式** | - `--dry_run` 标志：完全不向从臂发送指令，仅打印调试数据。<br>- 脚本异常或缺硬件时自动 fallback，保证脚本可随时离线运行。 |

## 2. 可调配置项 (`CONFIG`)

```python
CONFIG = {
    "scale": 1.0,    # 全局比例缩放
    "offsets": {      # 逐关节偏置 (deg)
        # 1: 5.0,      # 示例
    },
}
```
通过集中配置可快速迭代映射策略而无需触碰核心逻辑。

## 3. 关键代码段

> 以下代码片段节选自 `teleop_debug_node.py`，展示了若干核心机制的实现。

### 3.1 动态导入 DummyRobot / 模拟器

```python
follower_module = None
for mod_name in ("DummyRobot", "dummy_robot_simulator"):
    try:
        follower_module = __import__(mod_name)
        break
    except ModuleNotFoundError:
        continue

if follower_module is None:
    print("[WARN] 未找到 DummyRobot 库或模拟器，将在 dry-run 模式下运行。")
```

### 3.2 映射后安全阈值校验

```python
leader_pulses = tm.read_positions(leader, tm.LEADER_JOINT_IDS)
leader_angles_init = tm.pulse_to_angle(leader_pulses, tm.LEADER_JOINT_IDS)

# Leader → Follower 角度映射
follower_angles_init = tm.calculate_follower_angles(leader_angles_init)
# 手动 scale / offset 调整
follower_angles_init = apply_manual_adjustments(follower_angles_init)

init_err = calc_initial_error_deg(follower_angles_init, FOLLOWER_HOME_ANGLES)
# 当最大关节误差小于阈值时激活同步
is_active = init_err <= args.safety_deg
```

### 3.3 手动比例与偏置调整

```python
def apply_manual_adjustments(follower_angles: Dict[int, float]) -> Dict[int, float]:
    """应用全局 scale 及单关节 offset，返回新字典。"""
    adjusted: Dict[int, float] = {}
    for fid, ang in follower_angles.items():
        ang_adj = ang * CONFIG["scale"] + CONFIG["offsets"].get(fid, 0.0)
        adjusted[fid] = ang_adj
    return adjusted
```

### 3.4 主循环核心逻辑（节选）

```python
# —— Leader 读取 ——
pulses = tm.read_positions(leader, tm.LEADER_JOINT_IDS)
leader_angles = tm.pulse_to_angle(pulses, tm.LEADER_JOINT_IDS)

# —— 角度映射 ——
follower_angles = tm.calculate_follower_angles(leader_angles)
follower_angles = apply_manual_adjustments(follower_angles)

# —— 角度 → 计数 ——
follower_counts = {
    fid: tm.angle_to_counts(f_ang, fid)
    for fid, f_ang in follower_angles.items()
}

# —— 指令下发 (如果安全 & 非 dry-run) ——
if is_active and follower_axes is not None:
    with contextlib.redirect_stdout(io.StringIO()):
        for fid, cnt in follower_counts.items():
            follower_axes[fid].controller.pos_setpoint = cnt
```

## 4. 约束遵守情况

- **零侵入**：`teleop_mapping.py`、`DummyRobot` 及其它既有代码无任何改动。
- **模块化**：所有新增逻辑、参数与校准均封装于 `teleop_debug_node.py` 内部。
- **兼容性**：同一脚本即可适配真实硬件、模拟器及离线环境。

## 5. 运行示例

```bash
# 标准调试
python3 teleop_debug_node.py \
    --leader_port /dev/ttyUSB2 \
    --loop_hz 50 \
    --safety_deg 15

# 离线或演示
python3 teleop_debug_node.py --dry_run
```

---

> 若后续需求调整，请仅修改 `teleop_debug_node.py` 或以上 CONFIG 字典；
> 原有映射与 DummyRobot 代码依旧保持只读。
